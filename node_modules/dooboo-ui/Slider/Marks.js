import React, { useEffect, useMemo } from 'react';
import { StyleSheet, TouchableWithoutFeedback, } from 'react-native';
import styled from '@emotion/native';
const DEFAULT = {
    width: 3,
    height: 3,
};
const Container = styled.View `
  display: flex;
  justify-content: center;
  position: absolute;
`;
const MarkPositioner = styled.View `
  position: absolute;
  display: flex;
  align-items: center;
  width: ${({ width }) => width}px;
  left: ${({ position }) => position}px;
`;
const Mark = styled.View `
  width: ${DEFAULT.width}px;
  height: ${DEFAULT.height}px;
  background-color: #4163f4;
`;
// Checks if null or undefined. temporary until using othe library like 'lodash'.
const isNil = (value) => value == null;
const getMarkCountByStep = ({ step, startMark, endMark, minValue, maxValue, }) => {
    const count = Math.floor((maxValue - minValue) / step);
    const countToApply = count <= 0 ? 2 : count + 1;
    return countToApply - (startMark ? 0 : 1) - (endMark ? 0 : 1);
};
const getStepByMarkCount = ({ railWidth, count, startMark, endMark, }) => {
    const step = railWidth / count;
    if (startMark && endMark)
        return railWidth / (count - 1);
    if (!startMark && !endMark)
        return (railWidth - step) / count;
    return (railWidth - step) / (count - 1);
};
const getStepDistanceByMarkCount = ({ railWidth, markWidth, startMark, endMark, count, }) => {
    const getStepFineTunedStepByMark = ({ markWidth: currentMarkWidth, markCount, step, }) => {
        const fineTunerToFitMark = currentMarkWidth / markCount;
        return step - fineTunerToFitMark;
    };
    const stepToApply = getStepByMarkCount({
        railWidth,
        count,
        startMark,
        endMark,
    });
    return getStepFineTunedStepByMark({
        markWidth,
        markCount: count,
        step: stepToApply,
    });
};
const getStepDistanceByStep = ({ railWidth, markWidth, markCount, startMark, endMark, }) => {
    return getStepDistanceByMarkCount({
        railWidth,
        markWidth,
        startMark,
        endMark,
        count: markCount,
    });
};
const getStepDistance = ({ railWidth, markWidth, step, startMark, endMark, minValue, maxValue, }) => {
    const options = {
        railWidth,
        markWidth,
        startMark,
        endMark,
    };
    const count = getMarkCountByStep({
        step,
        startMark,
        endMark,
        minValue,
        maxValue,
    });
    return {
        markCount: count,
        stepDistance: getStepDistanceByStep({
            ...options,
            markCount: count,
        }),
    };
};
const getMarkPositions = ({ startMark, count, stepDistance, }) => {
    const startAt = startMark ? 0 : stepDistance;
    return Array.from({ length: count }).map((_, index) => startAt + stepDistance * index);
};
const getMarkValue = (step, markIndex) => step * markIndex;
const getMarkValues = (step, markPositions) => markPositions.map((_, index) => getMarkValue(step, index));
const createMarks = ({ positions, step, stepDistance, style, mark, markWidth, disabled, onMarkPress, }) => {
    const halfStepDistance = stepDistance / 2;
    const fineTunedHalfStepDistance = halfStepDistance - markWidth / 2;
    return positions.map((position, index) => {
        const handlePress = () => {
            if (disabled)
                return;
            const value = getMarkValue(step, index);
            if (onMarkPress)
                onMarkPress(value, position, index);
        };
        return (<TouchableWithoutFeedback key={position} onPress={handlePress}>
          <MarkPositioner width={stepDistance} position={position - fineTunedHalfStepDistance}>
            {mark || <Mark style={style}/>}
          </MarkPositioner>
        </TouchableWithoutFeedback>);
    });
};
const getMarkWidth = (markStyle) => {
    const { width } = markStyle;
    if (isNil(width))
        return DEFAULT.width;
    // eslint-disable-next-line radix
    return parseInt(width.toString());
};
const Marks = ({ testID, sliderWidth, style = {}, mark, customMarkWidth, step, startMark = true, endMark = true, disabled = false, onInit, onMarkPress, minValue, maxValue, }) => {
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const handleInit = (markValues, markPositions) => {
        if (onInit)
            onInit(markValues, markPositions);
    };
    if (mark && isNil(customMarkWidth))
        throw Error('Must have customMarkWidth prop if it uses a cutsom mark.');
    const markStyleToApply = StyleSheet.flatten(style);
    const railWidth = sliderWidth;
    const markWidth = isNil(mark)
        ? getMarkWidth(markStyleToApply)
        : customMarkWidth;
    const markOptions = {
        railWidth,
        markWidth,
        step,
        startMark,
        endMark,
        minValue,
        maxValue,
    };
    const { markCount: markCountToApply, stepDistance } = useMemo(() => getStepDistance(markOptions), 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Object.values(markOptions));
    const markPositions = useMemo(() => getMarkPositions({
        startMark,
        count: markCountToApply,
        stepDistance,
    }), [startMark, markCountToApply, stepDistance]);
    const marks = createMarks({
        positions: markPositions,
        step,
        stepDistance,
        style: markStyleToApply,
        mark,
        markWidth,
        disabled,
        onMarkPress,
    });
    useEffect(() => {
        const markValues = getMarkValues(step, markPositions);
        handleInit(markValues, markPositions);
    }, [handleInit, markPositions, step]);
    return (<Container testID={testID} style={style}>
      {marks}
    </Container>);
};
export default Marks;
